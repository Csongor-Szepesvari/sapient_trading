import pandas as pd
import duckdb
import os

def aggregate_signals(min_alpha_buy: float = 0.5, max_alpha_sell: float = -0.5) -> pd.DataFrame:
    """Combines sentiment and momentum to generate an alpha score and trading signals."""

    conn = duckdb.connect(database='./data/trading.duckdb', read_only=False)

    # Ensure features_daily view is registered
    conn.execute("CREATE OR REPLACE VIEW features_daily AS SELECT * FROM parquet_scan('data/lake/features/daily/*.parquet');")

    # Load features. For MVP, we assume news_sent and news_conf are already in features_daily
    # In a full pipeline, sentiment agent would write to features_daily as well.
    df_features = conn.execute("SELECT date, symbol, r20, news_sent, news_conf FROM features_daily ORDER BY date, symbol").fetchdf()

    if df_features.empty:
        print("No features data available for aggregation.")
        return pd.DataFrame(columns=['date', 'symbol', 'alpha', 'rationale'])

    # Simple aggregation: (news_sent + r20) / 2. More complex weighting could be done via config.
    # Handle potential NaNs if sentiment or r20 are missing for some entries
    df_features['news_sent'] = df_features['news_sent'].fillna(0) # Assume neutral if no sentiment
    df_features['r20'] = df_features['r20'].fillna(0) # Assume no momentum if no data

    df_features['alpha'] = (df_features['news_sent'] + df_features['r20']) / 2

    # Apply rules to generate signals and rationale
    def generate_signal_and_rationale(row):
        if row['alpha'] > min_alpha_buy:
            reason = f"Strong buy signal (alpha={row['alpha']:.2f}) based on positive news sentiment ({row['news_sent']:.2f}) and positive momentum (20D return={row['r20']:.2f})."
            return "BUY", reason
        elif row['alpha'] < max_alpha_sell:
            reason = f"Strong sell signal (alpha={row['alpha']:.2f}) based on negative news sentiment ({row['news_sent']:.2f}) and negative momentum (20D return={row['r20']:.2f})."
            return "SELL", reason
        else:
            reason = f"Hold signal (alpha={row['alpha']:.2f}) due to mixed or neutral signals (news sentiment={row['news_sent']:.2f}, 20D return={row['r20']:.2f})."
            return "HOLD", reason

    df_features[['side', 'reason']] = df_features.apply(lambda row: generate_signal_and_rationale(row), axis=1, result_type='expand')
    df_aggregated_signal = df_features[['date', 'symbol', 'alpha', 'reason', 'side']]

    # Placeholder for confidence. For MVP, we can derive it simply from alpha magnitude or a fixed value.
    df_aggregated_signal['conf'] = df_aggregated_signal['alpha'].abs()

    # Create a directory for aggregated signals
    output_dir = 'data/lake/aggregated_signals'
    os.makedirs(output_dir, exist_ok=True)

    # Write aggregated signals to Parquet
    df_aggregated_signal.to_parquet(os.path.join(output_dir, 'aggregated_signals.parquet'), index=False)
    print(f"Successfully generated aggregated signals and saved to {output_dir}/aggregated_signals.parquet")

    # Register in DuckDB
    conn.execute("CREATE OR REPLACE VIEW aggregated_signals AS SELECT * FROM parquet_scan('data/lake/aggregated_signals/*.parquet');")
    conn.close()

    return df_aggregated_signal

if __name__ == "__main__":
    # Example Usage:
    # This assumes that features_daily.parquet has been generated by features/daily.py
    # and potentially sentiment data from agents/sentiment/finbert_agent.py has been integrated.
    
    # For a quick test, you might need to run ingest_market.py, normalize_text.py, and calculate_daily_features first
    # to populate the necessary Parquet files and DuckDB views.

    # Example of creating dummy features_daily.parquet if it doesn't exist for isolated testing
    features_daily_path = 'data/lake/features/daily/features_daily.parquet'
    if not os.path.exists(features_daily_path):
        print(f"Dummy features_daily.parquet not found at {features_daily_path}. Creating for testing.")
        dummy_features = {
            'date': pd.to_datetime(['2023-01-01', '2023-01-01', '2023-01-02']),
            'symbol': ['AAPL', 'MSFT', 'AAPL'],
            'r20': [0.05, -0.02, 0.03],
            'news_sent': [0.8, -0.7, 0.1],
            'news_conf': [0.9, 0.85, 0.5]
        }
        os.makedirs(os.path.dirname(features_daily_path), exist_ok=True)
        pd.DataFrame(dummy_features).to_parquet(features_daily_path, index=False)

    aggregated_signals_df = aggregate_signals(min_alpha_buy=0.3, max_alpha_sell=-0.3)
    print("Aggregated Signals:")
    print(aggregated_signals_df)
